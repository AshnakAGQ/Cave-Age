<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_bug</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>template_enemy</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>604</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_inherited</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Initialize Enemy variables
image_speed = .1;
dir = -image_xscale;   // Enemy defaults to moving left
spd = 2;    // Default horizontal speed
grav = 1;   // Gravity work the same for enemies
hspd = 0;   // Default stopped
vspd = 0;   // Default stopped

// Ledge logic
avoid_ledges = true; 
under_enemy = 8; // Amount of pixels to check under object
killable = true; // Ability to be destroyed

onGround = -1;
onCeiling = -1;
onLeft = -1;
onRight = -1;

width = bbox_top - bbox_bottom;
length = bbox_right - bbox_left;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (onCeiling &amp;&amp; abs(obj_player.x - x) &lt; length &amp;&amp; y &lt; obj_player.y) scr_fix_crawler();

/// Enemy movement
var vertical = onLeft || onRight;
var horizontal = onCeiling || onGround; 
var inAir = !horizontal &amp;&amp; !vertical;

if (vertical)
{
    vspd = dir * spd;   //spd * -1 = up
    hspd = 0;
}
else if (horizontal)
{
    hspd = dir * spd;   //spd * -1 = left;
    vspd = 0;
}
else
{
    hspd = 0;
}

if (inAir) vspd += grav;   // Fall

// Horizontal wall collisions
if (horizontal &amp;&amp; place_meeting(x + hspd, y, obj_ground))
{
    // sign(x) = dir
    while(!place_meeting(x + sign(hspd), y, obj_ground))
    {
        // Move object 1 pixel at a time until it hits a collision
        x += sign(hspd);
    }
    hspd = 0; // Stop at walls
    
    if (!position_meeting(x + dir * length / 2, y + onCeiling * (length - width) / 2 , obj_ground)) 
    {   
        x += dir * (length + width)/2;
        y += onCeiling * (length + width)/2;
        
        // Rotate object at walls
        image_angle += 90 * dir * onGround;
        
        onRight = dir;
        onLeft = -onRight;
        dir = onCeiling;
        onCeiling = -1;
        onGround = -1;
        
        if (place_meeting(x, y, obj_ground))
        {
            onCeiling = dir;
            onGround = -onCeiling;
            dir = onLeft;
            onLeft = -1;
            onRight = -1;
            
            image_angle += 90 * dir * onGround;
            image_xscale *= -1;
            
            x += dir * (length + width)/2;
            y -= onCeiling * (length + width)/2;
        }
    }
    else
    {
        dir *= -1;
        image_xscale *= -1;
    }
}
// Horizontal ledge collision
else if (horizontal)
{
    if (onGround &amp;&amp; !position_meeting(x + hspd, bbox_bottom + length/2, obj_ground) &amp;&amp; !position_meeting(x + dir * length/2, bbox_bottom + length/2, obj_ground))
    {
        if (!place_meeting(x, bbox_bottom + length/2, obj_ground)) scr_fix_crawler();
        else
        {
            while(position_meeting(x + dir * width/2, bbox_bottom + length/2, obj_ground))
            {
                // Move object 1 pixel until no resistance
                x += sign(hspd);
            }
            hspd = 0; // Stop at ledge
            
            // Rotate object at walls
            image_angle += 90 * -dir;
            onLeft = dir;
            onRight = -onLeft;
            dir = onGround;
            onCeiling = -1;
            onGround = -1;
            
            if (place_meeting(x, y, obj_ground))
            {
                onGround = dir;
                onCeiling = -onGround;
                dir = onLeft;
                onLeft = -1;
                onRight = -1;
                
                image_angle -= 90 * dir;
                
                hspd = dir * spd;
            }
        }
    }
    else if (onCeiling &amp;&amp; !position_meeting(x + hspd, bbox_top - length/2, obj_ground) &amp;&amp; !position_meeting(x + dir * length/2, bbox_top - length/2, obj_ground))
    {
        if (!place_meeting(x, bbox_top - length/2, obj_ground)) scr_fix_crawler();
        else
        {
            while(position_meeting(x + dir * width/2, bbox_top - length/2, obj_ground))
            {
                // Move object 1 pixel until no resistance
                x += sign(hspd);
            }
            hspd = 0; // Stop at ledge
            
            // Rotate object at walls
            image_angle += 90 * dir;
            onLeft = dir;
            onRight = -onLeft;
            dir = onGround;
            onCeiling = -1;
            onGround = -1;
            
            hspd = 0;
            
            if (place_meeting(x, y, obj_ground))
            {
                onGround = dir;
                onCeiling = -onGround;
                dir = onLeft;
                onLeft = -1;
                onRight = -1;
                
                image_angle -= 90 * dir;
                
                hspd = dir * spd;
            }
        }
    } 
}

// Move horizontally
x += hspd;

// Vertical wall collisions
if (place_meeting(x, y + vspd, obj_ground))
{
    // sign(x) = x * -1
    while(!place_meeting(x, y + sign(vspd), obj_ground))
    {
        // Move object 1 pixel at a time until it hits a collision
        y += sign(vspd)
    }
    vspd = 0; // Stop at wall
    if (vertical)
    {
        if (!position_meeting(x + onLeft * (length - width) / 2, y + dir * length / 2, obj_ground)) 
        {
            y += dir * (length + width)/2;
            x += onLeft * (length + width)/2;
            
            // Rotate object at walls
            image_angle += 90 * -dir * onRight;
            
            onGround = dir;
            onCeiling = -onGround;
            dir = onLeft;
            onLeft = -1;
            onRight = -1;
            
            if (place_meeting(x, y, obj_ground))
            {
                onLeft = dir;
                onRight = -onLeft;
                dir = onCeiling;
                onCeiling = -1;
                onGround = -1;
                
                image_angle += 90 * -dir * onRight;
                image_xscale *= -1;
                
                y += dir * (length + width)/2;
                x -= onCeiling * (length + width)/2;
                
                
            }
        }
        else
        {
            dir *= -1;
            image_xscale *= -1;
        }
    }
    else onGround = 1;
}
// Vertical ledge collision
else if (vertical)
{
    if (onRight &amp;&amp; !position_meeting(bbox_right + length/2, y + vspd, obj_ground) &amp;&amp; !position_meeting(bbox_right + length/2, y + dir * length / 2, obj_ground))
    {
        if (onRight &amp;&amp; !place_meeting(bbox_right + length/2, y, obj_ground)) scr_fix_crawler();
        else
        {
            while(position_meeting(bbox_right + length/2, y + dir * width/2, obj_ground))
            {
                // Move object 1 pixel until no resistance
                y += sign(vspd);
            }          
            vspd = 0; // Stop at ledge
            
            // Rotate object at ledge
            image_angle += 90 * dir;
            onCeiling = dir;
            onGround = -onCeiling;
            dir = onRight;
            onLeft = -1;
            onRight = -1;
            
            if (place_meeting(x, y, obj_ground))
            {
                onRight = dir;
                onLeft = -onRight;
                dir = onCeiling;
                onCeiling = -1;
                onGround = -1;
                
                image_angle -= 90 * dir;
                
                vspd = dir * spd;
            }
        }
    }
    else if (onLeft &amp;&amp; !position_meeting(bbox_left - length/2, y + vspd, obj_ground) &amp;&amp; !position_meeting(bbox_left - length/2, y + dir * length/2, obj_ground))
    {
        if (!place_meeting(bbox_left - length/2, y, obj_ground)) scr_fix_crawler();
        else
        {
            while(position_meeting(bbox_left - length/2, y + dir * width/2, obj_ground))
            {
                // Move object 1 pixel until no resistance
                y += sign(vspd);
            }
            vspd = 0; // Stop at ledge
            
            // Rotate object at ledge
            image_angle += 90 * -dir;
            onCeiling = dir;
            onGround = -onCeiling;
            dir = onRight;
            onLeft = -1;
            onRight = -1;
            
            if (place_meeting(x, y, obj_ground))
            {
                onRight = dir;
                onLeft = -onRight;
                dir = onCeiling;
                onCeiling = -1;
                onGround = -1;
                
                image_angle -= 90 * dir;
                
                vspd = dir * spd;
            }
        }
    } 
}

//Move vertically
y += vspd;

// Player collisions

if(place_meeting(x,y,obj_player))
{
    if(killable &amp;&amp; obj_player.bbox_bottom &lt; y) // Player collides with top of enemy
    {
        with(obj_player)
        {
            vy = -jspd; // Make player jump
            
            audio_play_sound(snd_enemy_die, 0, false); // Enemy death sound
        }
        
        instance_destroy(); // Kill enemy object (instance)
    }
    else // Player collides with enemy, but not the top
    {
        scr_death();    // Will contain death functionality
    }  
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
